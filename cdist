#!/usr/bin/python

import os
import sys
import shutil
import glob
import tempfile
import argparse

class Environment(object):
    def __init__(self):
        self.environment = {}

    def set(self, a, b):
        self.environment[a] = b

    def get(self, a):
        return self.environment[a]

    def environment_string(self):
        e = ''
        for k, v in self.environment.iteritems():
            e += '%s="%s" ' % (k, v)
        return e
        
    def checkout(self, project, co):
        # XXX: would be git clone
        self.copytree('/home/carl/src/cdist5/%s' % project, '%s/src/%s' % (self.work_dir(), project))

    def read_cscript(self, project):
        cscript = {}
        execfile('%s/src/%s/cscript' % (self.work_dir(), project), cscript)
        return cscript

    # Install prefix (in sub-filesystem)
    def prefix(self):
        return self.work_dir(True)

    def build(self, project, cscript):
        self.build_dependencies(project, cscript)
        self.build_self(project, cscript)

    def build_dependencies(self, project, cscript):
        if 'dependencies' in cscript:
            for d in cscript['dependencies'](self):
                self.build(d)
    
    def build_self(self, project, cscript):
        self.chdir('%s/src/%s' % (self.work_dir(True), project))
        cscript['build'](self)

    def rmtree(self, t):
        print 'rm -r %s' % t
        shutil.rmtree(t, ignore_errors=True)

    def copytree(self, a, b):
        print 'cp -r %s %s' % (a, b)
        shutil.copytree(a, b)

    def setup(self, project, co):
        self.checkout(project, co)
        return self.read_cscript(project)


class ChrootEnvironment(Environment):
    def __init__(self, chroot):
        super(ChrootEnvironment, self).__init__()
        self.chroot = chroot
        self.dir_in_chroot = '/home/carl'
        self.chroot_dir = '/home/carl/Environments'
        # cwd for command()s as a full path in the sub-filesystem
        self.cwd = self.dir_in_chroot
        for g in glob.glob('%s/*' % self.work_dir(False)):
            self.rmtree(g)

        self.set('CXXFLAGS', '-I%s/include' % self.prefix())
        self.set('LINKFLAGS', '-L%s/lib' % self.prefix())
        self.set('PKG_CONFIG_PATH', '%s/lib/pkgconfig' % self.prefix())

    def work_dir(self, sub = False):
        if sub:
            return self.dir_in_chroot
        else:
            return '%s/%s%s' % (self.chroot_dir, self.chroot, self.dir_in_chroot)

    def command(self, c):
        print 'schroot -> %s' % c
        os.system('%s schroot -c %s -d %s -p -- %s' % (self.environment_string(), self.chroot, self.cwd, c))

    # chdir in sub-filesystem
    def chdir(self, d):
        if len(d) > 0 and d[0] == '/':
            self.cwd = d
        else:
            self.cwd += '/' + d

    def target_type(self):
        return 'linux'

    def package(self, project, cscript):
        self.build_dependencies(project, cscript)
        r = cscript['package'](self)
        return '%s/%s%s' % (self.chroot_dir, self.chroot, r)

    def operating_system(self):
        return self.chroot.split('-')[0]

    def version(self):
        return self.chroot.split('-')[1]

    def bits(self):
        return int(self.chroot.split('-')[2])


class HostEnvironment(Environment):
    def __init__(self):
        super(HostEnvironment, self).__init__()
        self.temp = tempfile.mkdtemp()
        print 'temp is %s' % self.temp

    def work_dir(self, sub = False):
        return self.temp

    def command(self, c):
        print 'base -> %s' % c
        print self.environment_string()
        os.system('%s %s' % (self.environment_string(), c))

    def chdir(self, d):
        os.chdir(d)

    def cleanup(self):
        self.rmtree(self.temp)

    def package(self, project, cscript):
        

class WindowsEnvironment(HostEnvironment):
    def __init__(self, bits):
        super(WindowsEnvironment, self).__init__()
        self.set('PATH', os.environ['PATH'])

        self._bits = bits
        self._windows_prefix = '/home/carl/Environments/windows/%d' % self._bits
        if self._bits == 32:
            self.mingw_name = 'i686'
        else:
            self.mingw_name = 'x86_64'

        self.mingw_path = '/mingw/bin'
        self.mingw_prefix = '/mingw/%s-w64-mingw32' % self.mingw_name

        self.set('PKG_CONFIG_LIBDIR', '%s/lib/pkgconfig' % self._windows_prefix)
        self.set('PKG_CONFIG_PATH', '%s/lib/pkgconfig' % self.prefix())
        self.set('PATH', '%s/bin:%s:%s' % (self._windows_prefix, self.mingw_path, self.get('PATH')))
        self.set('CC', '%s-w64-mingw32-gcc' % self.mingw_name)
        self.set('CXX', '%s-w64-mingw32-g++' % self.mingw_name)
        self.set('LD', '%s-w64-mingw32-ld' % self.mingw_name)
        self.set('RANLIB', '%s-w64-mingw32-ranlib' % self.mingw_name)
        self.set('WINRC', '%s-w64-mingw32-windres' % self.mingw_name)
        self.set('CXXFLAGS', '-I%s/include -I%s/include -I%s/include' % (self._windows_prefix, self.mingw_prefix, self.prefix()))
        self.set('LINKFLAGS', '-L%s/lib -L%s/lib -L%s/lib' % (self._windows_prefix, self.mingw_prefix, self.prefix()))

    def host(self):
        return '%s-w64-mingw32' % self.mingw_name

    def target_type(self):
        return 'windows'

    def bits(self):
        return self._bits

    def windows_prefix(self):
        return self._windows_prefix

    def package(self, project, cscript):
        self.build_dependencies(project, cscript)
        self.build_self(project, cscript)
        return cscript['package'](self)


def build_ubuntu(target):
    env = ChrootEnvironment(target)

    


e = ChrootEnvironment('ubuntu-12.04-32')
c = e.setup('dvdomatic', None)
e.package('dvdomatic', c)
#e.build('ffmpeg')
#e.cleanup()

sys.exit(0)

def error(e):
    print 'Error: %s' % e
    sys.exit(1)

def environment_factory(t):
    if t.startswith('ubuntu-'):
        return ChrootEnvironment(t)
    if t.startswith('windows-'):
        bits = int(t.split('-')[1])
        if bits == 32 or bits == 64:
            return WindowsEnvironment(bits)

    error('invalid target %s' % t)

parser = argparse.ArgumentParser()
parser.add_argument('command')
parser.add_argument('-p', '--project', help='project name', required=True)
parser.add_argument('--beta', help='beta release', action='store_true')
parser.add_argument('--full', help='full release', action='store_true')
parser.add_argument('-c', '--checkout', help='string to pass to git for checkout')
parser.add_argument('-o', '--output', help='output directory', default='.')
parser.add_argument('-q', '--quiet', help='be quiet', action='store_true')
parser.add_argument('-t', '--target', help='target')
args = parser.parse_args()

if args.command is 'build':
    if args.project is None:
        error('you must specify -p or --project')
    if args.target is None:
        error('you must specify -t or --target')

    env = environment_factory(t)
    cscript = env.setup(args.project, args.checkout)
    env.build(args.project, cscript)

elif args.command is 'package':
    if args.project is None:
        error('you must specify -p or --project')
    if args.target is None:
        error('you must specify -t or --target')
        
    env = environment_factory(t)
    cscript = env.setup(args.project, args.checkout)
    r = env.package(args.project)
    shutil.copyfile(r, '%s/%s' % (args.output, os.path.basename(r)))
