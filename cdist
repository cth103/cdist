#!/usr/bin/python

#    Copyright (C) 2012 Carl Hetherington <cth@carlh.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#
# Configuration
#

# Directory to build things in within chroots
DIR_IN_CHROOT = '/home/carl'
# Prefix of chroots in the filesystem
CHROOT_PREFIX = '/home/carl/Environments'
# Prefix of windows environments
WINDOWS_ENVIRONMENT_PREFIX = '/home/carl/Environments/windows'
# Git prefix
GIT_DIR = 'ssh://houllier/home/carl/git'
OSX_BUILD_HOST = 'carl@192.168.1.94'
DIR_ON_HOST = '/Users/carl/cdist'
OSX_ENVIRONMENT_PREFIX = '/Users/carl/Environments/osx/10.8'


import os
import sys
import shutil
import glob
import tempfile
import argparse
import datetime
import subprocess
import re

#
# Utility bits
# 

def log(m):
    if not args.quiet:
        print '\x1b[33m* %s\x1b[0m' % m

def error(e):
    print '\x1b[31mError: %s\x1b[0m' % e
    sys.exit(1)

def copytree(a, b):
    log('copy %s -> %s' % (a, b))
    shutil.copytree(a, b)

def copyfile(a, b):
    log('copy %s -> %s' % (a, b))
    shutil.copyfile(a, b)

def rmdir(a):
    log('remove %s' % a)
    os.rmdir(a)

def rmtree(a):
    log('remove %s' % a)
    shutil.rmtree(a, ignore_errors=True)

def command(c, can_fail=False):
    log(c)
    r = os.system(c)
    if (r >> 8) and not can_fail:
        error('command %s failed' % c)

def command_and_read(c):
    log(c)
    p = subprocess.Popen(c.split(), stdout=subprocess.PIPE)
    f = os.fdopen(os.dup(p.stdout.fileno()))
    return f


#
# Version
#

class Version:
    def __init__(self, s):
        self.pre = False
        self.beta = None

        if s.startswith("'"):
            s = s[1:]
        if s.endswith("'"):
            s = s[0:-1]
        
        if s.endswith('pre'):
            s = s[0:-3]
            self.pre = True

        b = s.find("beta")
        if b != -1:
            self.beta = int(s[b+4:])
            s = s[0:b]

        p = s.split('.')
        self.major = int(p[0])
        self.minor = int(p[1])

    def bump(self):
        self.minor += 1
        self.pre = False
        self.beta = None

    def to_pre(self):
        self.pre = True
        self.beta = None

    def bump_and_to_pre(self):
        self.bump()
        self.pre = True
        self.beta = None

    def to_release(self):
        self.pre = False
        self.beta = None

    def bump_beta(self):
        if self.pre:
            self.pre = False
            self.beta = 1
        elif self.beta is not None:
            self.beta += 1
        elif self.beta is None:
            self.beta = 1

    def __str__(self):
        s = '%d.%02d' % (self.major, self.minor)
        if self.beta is not None:
            s += 'beta%d' % self.beta
        elif self.pre:
            s += 'pre'

        return s


#
# Environment
#

class Environment(object):
    def __init__(self):
        self.variables = {}

    def set(self, a, b):
        self.variables[a] = b

    def get(self, a):
        return self.variables[a]

    def variables_string(self, escaped_quotes=False):
        e = ''
        for k, v in self.variables.iteritems():
            if escaped_quotes:
                v = v.replace('"', '\\"')
            e += '%s=%s ' % (k, v)
        return e

    def work_dir_cdist(self, sub):
        assert(false)

    def work_dir_cscript(self):
        assert(false)

    def build_dependencies(self, target, project):
        cwd = os.getcwd()
        if 'dependencies' in project.cscript:
            for d in project.cscript['dependencies'](target):
                dep = Project(d[0], '.', d[1])
                dep.checkout(self)
                self.build(target, dep)
        os.chdir(cwd)

    def build(self, target, project):
        project.cscript['build'](self, target)

    def package(self, target, project):
        project.checkout(self)
        if target.platform != 'source':
            self.build_dependencies(target, project)
        if target.platform == 'source':
            command('./waf dist')
            if project.directory != '.':
                return os.path.abspath('%s-%s.tar.bz2' % (project.directory, project.version))
            return os.path.abspath('%s-%s.tar.bz2' % (project.name, project.version))
        else:
            project.cscript['build'](self, target)
            return project.cscript['package'](self, target, project.version)

    def cleanup(self):
        pass

#
# ChrootEnvironment
#

class ChrootEnvironment(Environment):
    def __init__(self, chroot):
        super(ChrootEnvironment, self).__init__()
        self.chroot = chroot
        self.dir_in_chroot = DIR_IN_CHROOT
        self.chroot_dir = CHROOT_PREFIX

        # ChrootEnvironments work in dir_in_chroot, and clear
        # it out before use
        for g in glob.glob('%s/*' % self.work_dir_cdist()):
            rmtree(g)

        # Environment variables
        self.set('CXXFLAGS', '-I%s/include' % self.work_dir_cscript())
        self.set('LINKFLAGS', '-L%s/lib' % self.work_dir_cscript())
        self.set('PKG_CONFIG_PATH', '%s/lib/pkgconfig' % self.work_dir_cscript())

    def work_dir_cdist(self):
        return '%s/%s%s' % (self.chroot_dir, self.chroot, self.dir_in_chroot)

    def work_dir_cscript(self):
        return self.dir_in_chroot

    def command(self, c):
        # Work out the cwd for the chrooted command
        cwd = os.getcwd()
        prefix = '%s/%s' % (self.chroot_dir, self.chroot)
        assert(cwd.startswith(prefix))
        cwd = cwd[len(prefix):]

        log('schroot [%s] -> %s' % (cwd, c))
        command('%s schroot -c %s -d %s -p -- %s' % (self.variables_string(), self.chroot, cwd, c))


#
# RemoteEnvironment
#

class RemoteEnvironment(Environment):
    def __init__(self, host):
        super(RemoteEnvironment, self).__init__()
        self.host = host
        self.dir_on_host = DIR_ON_HOST
        self.host_mount_dir = tempfile.mkdtemp()

        # Mount the remote host on host_mount_dir
        command('sshfs %s:%s %s' % (self.host, self.dir_on_host, self.host_mount_dir))
        for g in glob.glob('%s/*' % self.host_mount_dir):
            rmtree(g)

        # Environment variables
        self.set('CXXFLAGS', '"-I%s/include -I%s/include"' % (self.dir_on_host, OSX_ENVIRONMENT_PREFIX))
        self.set('LINKFLAGS', '"-L%s/lib -L%s/lib"' % (self.dir_on_host, OSX_ENVIRONMENT_PREFIX))
        self.set('PKG_CONFIG_PATH', '%s/lib/pkgconfig:%s/lib/pkgconfig' % (self.dir_on_host, OSX_ENVIRONMENT_PREFIX))
        self.set('PATH', '$PATH:/usr/local/bin:%s/bin' % OSX_ENVIRONMENT_PREFIX)

    def work_dir_cdist(self):
        return self.host_mount_dir

    def work_dir_cscript(self):
        return self.dir_on_host

    def command(self, c):
        # Work out the cwd for the chrooted command
        cwd = os.getcwd()
        assert(cwd.startswith(self.host_mount_dir))
        cwd = cwd[len(self.host_mount_dir):]

        log('ssh [%s] -> %s' % (cwd, c))
        command('ssh %s -- "cd %s%s; %s %s"' % (self.host, self.dir_on_host, cwd, self.variables_string(True), c))

    def cleanup(self):
        os.chdir('/')
        command('fusermount -u %s' % self.host_mount_dir)
        rmdir(self.host_mount_dir)

#
# HostEnvironment
#

class HostEnvironment(Environment):
    def __init__(self, directory=None):
        super(HostEnvironment, self).__init__()
        if directory is None:
            self.directory = tempfile.mkdtemp()
            self.rmdir = True
        else:
            self.directory = directory
            self.rmdir = False

    def work_dir_cdist(self):
        return self.directory

    def work_dir_cscript(self):
        return self.directory

    def command(self, c):
        log('host -> %s' % c)
        command('%s %s' % (self.variables_string(), c))

    def cleanup(self):
        if self.rmdir:
            rmtree(self.directory)


def prepare_for_windows(env, bits):
    env.windows_prefix = '%s/%d' % (WINDOWS_ENVIRONMENT_PREFIX, bits)
    if not os.path.exists(env.windows_prefix):
        error('windows prefix %s does not exist' % env.windows_prefix)

    if bits == 32:
        mingw_name = 'i686'
    else:
        mingw_name = 'x86_64'

    mingw_path = '/mingw/%d/bin' % bits
    mingw_prefixes = ['/mingw/%d' % bits, '/mingw/%d/%s-w64-mingw32' % (bits, mingw_name)]

    env.set('PKG_CONFIG_LIBDIR', '%s/lib/pkgconfig' % env.windows_prefix)
    env.set('PKG_CONFIG_PATH', '%s/lib/pkgconfig' % env.work_dir_cscript())
    env.set('PATH', '%s/bin:%s:%s' % (env.windows_prefix, mingw_path, os.environ['PATH']))
    env.set('CC', '%s-w64-mingw32-gcc' % mingw_name)
    env.set('CXX', '%s-w64-mingw32-g++' % mingw_name)
    env.set('LD', '%s-w64-mingw32-ld' % mingw_name)
    env.set('RANLIB', '%s-w64-mingw32-ranlib' % mingw_name)
    env.set('WINRC', '%s-w64-mingw32-windres' % mingw_name)
    cxx = '-I%s/include -I%s/include' % (env.windows_prefix, env.work_dir_cscript())
    link = '-L%s/lib -L%s/lib' % (env.windows_prefix, env.work_dir_cscript())
    for p in mingw_prefixes:
        cxx += ' -I%s/include' % p
        link += ' -L%s/lib' % p
    env.set('CXXFLAGS', '"%s"' % cxx)
    env.set('LINKFLAGS', '"%s"' % link)


#
# Target
#

class Target:
    def __init__(self, name):
        self.name = name
        if name.startswith('ubuntu-') or name.startswith('debian-'):
            self.platform = 'linux'
            self.version = name.split('-')[1]
            self.bits = int(name.split('-')[2])
        elif name.startswith('windows-'):
            self.platform = 'windows'
            self.bits = int(name.split('-')[1])
        elif name == 'osx':
            self.platform = 'osx'
        elif name == 'source':
            self.platform = 'source'

def environment_for_target(target, directory):
    if target.platform == 'linux':
        return ChrootEnvironment(target.name)
    elif target.platform == 'windows':
        env = HostEnvironment(directory)
        prepare_for_windows(env, target.bits)
        return env
    elif target.platform == 'osx':
        env = RemoteEnvironment(OSX_BUILD_HOST)
        return env
    elif target.platform == 'source':
        return HostEnvironment()

    return None

#
# Project
#
 
class Project(object):
    def __init__(self, name, directory, specifier=None):
        self.name = name
        self.directory = directory
        self.git_dir = GIT_DIR
        self.version = None
        self.specifier = specifier
        if self.specifier is None:
            self.specifier = 'master'

    def checkout(self, env):
        flags = ''
        redirect = ''
        if args.quiet:
            flags = '-q'
            redirect = '>/dev/null'
        command('git clone --depth 0 %s %s/%s.git %s/src/%s' % (flags, self.git_dir, self.name, env.work_dir_cdist(), self.name))
        os.chdir('%s/src/%s' % (env.work_dir_cdist(), self.name))
        command('git checkout %s %s %s' % (flags, self.specifier, redirect))
        command('git submodule init')
        command('git submodule update')
        os.chdir(self.directory)

        proj = '%s/src/%s/%s' % (env.work_dir_cdist(), self.name, self.directory)

        self.read_cscript('%s/cscript' % proj)
        
        if os.path.exists('%s/wscript' % proj):
            f = open('%s/wscript' % proj, 'r')
            version = None
            while 1:
                l = f.readline()
                if l == '':
                    break

                s = l.split()
                if len(s) == 3 and s[0] == "VERSION":
                    self.version = Version(s[2])

            f.close()

    def read_cscript(self, s):
        self.cscript = {}
        execfile(s, self.cscript)

def set_version_in_wscript(version):
    f = open('wscript', 'rw')
    o = open('wscript.tmp', 'w')
    while 1:
        l = f.readline()
        if l == '':
            break

        s = l.split()
        if len(s) == 3 and s[0] == "VERSION":
            print "Writing %s" % version
            print >>o,"VERSION = '%s'" % version
        else:
            print >>o,l,
    f.close()
    o.close()

    os.rename('wscript.tmp', 'wscript')

def append_version_to_changelog(version):
    try:
        f = open('ChangeLog', 'r')
    except:
        log('Could not open ChangeLog')
        return

    c = f.read()
    f.close()

    f = open('ChangeLog', 'w')
    now = datetime.datetime.now()
    f.write('%d-%02d-%02d  Carl Hetherington  <cth@carlh.net>\n\n\t* Version %s released.\n\n' % (now.year, now.month, now.day, version))
    f.write(c)

def append_version_to_debian_changelog(version):
    if not os.path.exists('debian'):
        log('Could not find debian directory')
        return

    command('dch -b -v %s-1 "New upstream release."' % version)

#
# Command-line parser
#

parser = argparse.ArgumentParser()
parser.add_argument('command')
parser.add_argument('-p', '--project', help='project name', required=True)
parser.add_argument('-d', '--directory', help='directory within project repo', default='.')
parser.add_argument('--beta', help='beta release', action='store_true')
parser.add_argument('--full', help='full release', action='store_true')
parser.add_argument('-c', '--checkout', help='string to pass to git for checkout')
parser.add_argument('-o', '--output', help='output directory', default='.')
parser.add_argument('-q', '--quiet', help='be quiet', action='store_true')
parser.add_argument('-t', '--target', help='target')
parser.add_argument('-k', '--keep', help='keep working tree', action='store_true')
args = parser.parse_args()

args.output = os.path.abspath(args.output)

if args.project is None:
    error('you must specify -p or --project')

project = Project(args.project, args.directory, args.checkout)

if args.command == 'build':
    if args.target is None:
        error('you must specify -t or --target')

    target = Target(args.target)
    env = environment_for_target(target, None)
    project.checkout(env)
    env.build_dependencies(target, project)
    env.build(target, project)

    env.cleanup()

elif args.command == 'package':
    if args.target is None:
        error('you must specify -t or --target')
        
    target = Target(args.target)
    env = environment_for_target(target, None)

    packages = env.package(target, project)
    if hasattr(packages, 'strip') or (not hasattr(packages, '__getitem__') and not hasattr(packages, '__iter__')):
        packages = [packages]

    if target.platform == 'linux':
        out = '%s/%s-%d' % (args.output, target.version, target.bits)
        try:
            os.makedirs(out)
        except:
            pass
        for p in packages:
            copyfile(p, '%s/%s' % (out, os.path.basename(p)))
    else:
        for p in packages:
            copyfile(p, '%s/%s' % (args.output, os.path.basename(p)))

    env.cleanup()

elif args.command == 'release':
    if args.full is False and args.beta is False:
        error('you must specify --full or --beta')

    env = HostEnvironment()
    project.checkout(env)

    version = project.version
    if args.full:
        version.to_release()
    else:
        version.bump_beta()

    set_version_in_wscript(version)
    append_version_to_changelog(version)
    append_version_to_debian_changelog(version)

    command('git commit -a -m "Bump version"')
    command('git tag -m "v%s" v%s' % (version, version))

    if args.full:
        version.bump_and_to_pre()
        set_version_in_wscript(version)
        command('git commit -a -m "Bump version"')

    command('git push')
    command('git push --tags')

    env.cleanup()

elif args.command == 'pot':
    env = HostEnvironment()
    project.checkout(env)

    pots = project.cscript['make_pot'](env)
    for p in pots:
        copyfile(p, '%s/%s' % (args.output, os.path.basename(p)))

    env.cleanup()

elif args.command == 'changelog':
    env = HostEnvironment()
    project.checkout(env)

    text = open('ChangeLog', 'r')
    html = open('%s/changelog.html' % args.output, 'w')
    versions = 8
    
    last = None
    changes = []
    
    while 1:
        l = text.readline()
        if l == '':
            break
    
        if len(l) > 0 and l[0] == "\t":
            s = l.split()
            if len(s) == 4 and s[1] == "Version" and s[3] == "released.":
                if not "beta" in s[2]:
                    if last is not None and len(changes) > 0:
                        print >>html,"<h2>Changes between version %s and %s</h2>" % (s[2], last)
                        print >>html,"<ul>"
                        for c in changes:
                            print >>html,"<li>%s" % c
                        print >>html,"</ul>"
                    last = s[2]
                    changes = []
                    versions -= 1
                    if versions < 0:
                        break
            else:
                c = l.strip()
                if len(c) > 0:
                    if c[0] == '*':
                        changes.append(c[2:])
                    else:
                        changes[-1] += " " + c

    env.cleanup()

elif args.command == 'manual':
    env = HostEnvironment()
    project.checkout(env)

    dirs = project.cscript['make_manual'](env)
    for d in dirs:
        copytree(d, '%s/%s' % (args.output, os.path.basename(d)))

    env.cleanup()

elif args.command == 'doxygen':
    env = HostEnvironment()
    project.checkout(env)

    dirs = project.cscript['make_doxygen'](env)
    if hasattr(dirs, 'strip') or (not hasattr(dirs, '__getitem__') and not hasattr(dirs, '__iter__')):
        dirs = [dirs]

    for d in dirs:
        copytree(d, '%s/%s' % (args.output, 'doc'))

    env.cleanup()

elif args.command == 'latest':
    env = HostEnvironment()
    project.checkout(env)

    f = command_and_read('git log --tags --simplify-by-decoration --pretty="%d"')
    t = f.readline()
    m = re.compile(".*\((.*)\).*").match(t)
    latest = None
    if m:
        tags = m.group(1).split(', ')
        for t in tags:
            if len(t) > 0 and t[0] == 'v':
                latest = t[1:]

    print latest
    env.cleanup()

elif args.command == 'test':
    if args.target is None:
        error('you must specify -t or --target')

    target = Target(args.target)
    env = environment_for_target(target, '.')
    project.read_cscript('cscript')
    env.build(target, project)

else:
    error('invalid command %s' % args.command)
